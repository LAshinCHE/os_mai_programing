# -fpic
генерирует позиционно-независимый код (PIC), пригодный для использования в общей библиотеке

Сводка теории:

Если кратко, то, когда линкер создает разделяемую библиотеку, он заранее не знает,в каком месте в памяти она будет загружена. 
Из-за этого делать ссылки на данные и код внутри библиотеки проблематично: непонятно, как создавать ссылку, чтобы она 
указывала в правильное место после того, как библиотека будет загружена.

Решение 
1. Релокация во время загрузки(Занимает много времени, поэтому в случае если приходиться приложению загружать несколько больших
библиотек, то является не эффективным способо,так же нельзя изменять text-секцию(где хранится машинный код), для каждого процесса
приходится иметь свою копию библеотеки, держать text-секцию с правами на запись не безопасно)
2. (Position-independent code(PIC))(Более популярна в наше время)

## Немного про секции 
Когда мы компилируем исходный файл, на выходе мы получаем файл объектный, который типично содержит в себе несколько секций с данными. Четыре самые распространенные секции это:

    .text — скомпилированный машинный код;
    .data — глобальные и статические переменные;
    .rodata — аналог .data для неизменяемых данных;
    .bss — глобальные и статические переменные, которые при старте содержат нулевое значение.




## Идея
PIC – добавление в код промежуточного слоя для всех ссылок на глобальные объекты и функции.(Если по-умному использовать некоторые артефакты процессов линковки и загрузки, можно сделать раздел text действительно не зависящим от адреса, куда его положат; мы сможем отобразить сегмент с помощью mmap на самые разные адреса в адресном пространстве процесса, и нам не понадобится изменять в нём ни один бит.)

Одна из ключевых идей, на которых основывается PIC, – смещение между секциями text и data, размер которого известен линкеру во время линковки. Когда линкер объединяет несколько объектных файлов, он собирает их секции вместе (к примеру, все секции text объединяются в одну большую секцию text). Таким образом, линкеру известны и размеры секций, и их относительное расположение.

Например, сразу за секцией text может следовать секция data, и в этом случае смещение от любой инструкции из секции text до начала секции data будет равняться размеру секции text минус смещение до данной инструкции от начала секции text. И все эти размеры и смещения известны линкеру.
## GOT
GOT – это просто таблица с адресами, которая находится в секции data. Предположим, что какая-то инструкция в секции code хочет обратиться к переменной. Вместо того, чтобы обратится к ней через абсолютный адрес (который потребует релокации), она обращается к записи в GOT. Поскольку GOT имеет строго определённое место в секции data, и линкер знает о нём, это обращение тоже является относительным. А запись в GOT уже содержит абсолютный адрес переменной


## ldd
показывает все подключенные динамические библиотеки